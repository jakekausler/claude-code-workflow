# Stage 5.5B: Skill Updates — Branch Chain & Draft MR — Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Update phase skills to consume graduated dependency resolution (parent branch merging, draft MRs, conflict resolution) and add code host adapter methods for MR management.

**Architecture:** Three adapter methods added to the existing `CodeHostAdapter` interface with GitHub/GitLab implementations. Three skill files modified/created: `phase-build` gets a parent merge step, `phase-finalize` gets draft MR logic, and a new `resolve-merge-conflicts` skill is created.

**Tech Stack:** TypeScript (Vitest for testing), Markdown skill files, `gh`/`glab` CLIs

---

### Task 1: Extend CodeHostAdapter interface with new method signatures

**Files:**
- Modify: `tools/kanban-cli/src/resolvers/types.ts:30-34`

**Step 1: Add three new methods to the CodeHostAdapter interface**

In `tools/kanban-cli/src/resolvers/types.ts`, replace the existing `CodeHostAdapter` interface:

```typescript
/**
 * Adapter for querying and managing code host (GitHub/GitLab) PR/MR status.
 * Implementations can shell out to `gh`/`glab` CLI or call APIs directly.
 */
export interface CodeHostAdapter {
  getPRStatus(prUrl: string): PRStatus;

  /**
   * Retarget a PR/MR to a different base branch.
   * Throws on failure — callers need to know if the mutation failed.
   */
  editPrBase(prNumber: number, newBase: string): void;

  /**
   * Promote a draft PR/MR to ready for review.
   * Throws on failure — callers need to know if the mutation failed.
   */
  markPrReady(prNumber: number): void;

  /**
   * Get the commit SHA at the head of a branch.
   * Returns empty string on failure (safe default).
   */
  getBranchHead(branch: string): string;
}
```

**Step 2: Commit**

```bash
git add tools/kanban-cli/src/resolvers/types.ts
git commit -m "feat(5.5B): extend CodeHostAdapter with editPrBase, markPrReady, getBranchHead"
```

---

### Task 2: Write failing tests for GitHub adapter new methods

**Files:**
- Modify: `tools/kanban-cli/tests/utils/code-host-github.test.ts`

**Step 1: Add test cases for `editPrBase`**

Append to the `createGitHubAdapter` describe block:

```typescript
  describe('editPrBase', () => {
    it('passes correct args to gh CLI', () => {
      let capturedCmd = '';
      let capturedArgs: string[] = [];
      const adapter = createGitHubAdapter({
        execFn: (cmd, args) => {
          capturedCmd = cmd;
          capturedArgs = args;
          return '';
        },
      });
      adapter.editPrBase(42, 'main');
      expect(capturedCmd).toBe('gh');
      expect(capturedArgs).toEqual([
        'pr', 'edit', '42',
        '--base', 'main',
      ]);
    });

    it('throws when CLI fails', () => {
      const adapter = createGitHubAdapter({
        execFn: () => { throw new Error('gh not found'); },
      });
      expect(() => adapter.editPrBase(42, 'main')).toThrow('gh not found');
    });
  });
```

**Step 2: Add test cases for `markPrReady`**

```typescript
  describe('markPrReady', () => {
    it('passes correct args to gh CLI', () => {
      let capturedArgs: string[] = [];
      const adapter = createGitHubAdapter({
        execFn: (_cmd, args) => {
          capturedArgs = args;
          return '';
        },
      });
      adapter.markPrReady(42);
      expect(capturedArgs).toEqual(['pr', 'ready', '42']);
    });

    it('throws when CLI fails', () => {
      const adapter = createGitHubAdapter({
        execFn: () => { throw new Error('gh not found'); },
      });
      expect(() => adapter.markPrReady(42)).toThrow('gh not found');
    });
  });
```

**Step 3: Add test cases for `getBranchHead`**

```typescript
  describe('getBranchHead', () => {
    it('extracts SHA from gh api response', () => {
      const apiResponse = JSON.stringify({
        object: { sha: 'abc123def456' },
      });
      const adapter = createGitHubAdapter({
        execFn: () => apiResponse,
      });
      expect(adapter.getBranchHead('feature/auth')).toBe('abc123def456');
    });

    it('passes correct args to gh api', () => {
      let capturedArgs: string[] = [];
      const adapter = createGitHubAdapter({
        execFn: (_cmd, args) => {
          capturedArgs = args;
          return JSON.stringify({ object: { sha: 'abc123' } });
        },
      });
      adapter.getBranchHead('feature/auth');
      expect(capturedArgs).toEqual([
        'api', 'repos/{owner}/{repo}/git/ref/heads/feature/auth',
      ]);
    });

    it('returns empty string when CLI fails', () => {
      const adapter = createGitHubAdapter({
        execFn: () => { throw new Error('gh not found'); },
      });
      expect(adapter.getBranchHead('feature/auth')).toBe('');
    });
  });
```

**Step 4: Run tests to verify they fail**

```bash
cd tools/kanban-cli && npx vitest run tests/utils/code-host-github.test.ts
```

Expected: FAIL — `editPrBase`, `markPrReady`, `getBranchHead` are not yet implemented.

**Step 5: Commit failing tests**

```bash
git add tools/kanban-cli/tests/utils/code-host-github.test.ts
git commit -m "test(5.5B): add failing tests for GitHub adapter new methods"
```

---

### Task 3: Implement GitHub adapter new methods

**Files:**
- Modify: `tools/kanban-cli/src/utils/code-host-github.ts`

**Step 1: Add `editPrBase`, `markPrReady`, `getBranchHead` to the returned object**

In the `createGitHubAdapter` function, extend the returned object after the `getPRStatus` method:

```typescript
    editPrBase(prNumber: number, newBase: string): void {
      exec('gh', ['pr', 'edit', String(prNumber), '--base', newBase]);
    },

    markPrReady(prNumber: number): void {
      exec('gh', ['pr', 'ready', String(prNumber)]);
    },

    getBranchHead(branch: string): string {
      try {
        const json = exec('gh', [
          'api', `repos/{owner}/{repo}/git/ref/heads/${branch}`,
        ]);
        const data = JSON.parse(json) as { object: { sha: string } };
        return data.object.sha;
      } catch {
        return '';
      }
    },
```

**Step 2: Run tests to verify they pass**

```bash
cd tools/kanban-cli && npx vitest run tests/utils/code-host-github.test.ts
```

Expected: ALL PASS

**Step 3: Commit**

```bash
git add tools/kanban-cli/src/utils/code-host-github.ts
git commit -m "feat(5.5B): implement GitHub adapter editPrBase, markPrReady, getBranchHead"
```

---

### Task 4: Write failing tests for GitLab adapter new methods

**Files:**
- Modify: `tools/kanban-cli/tests/utils/code-host-gitlab.test.ts`

**Step 1: Add test cases for `editPrBase`**

Append to the `createGitLabAdapter` describe block:

```typescript
  describe('editPrBase', () => {
    it('passes correct args to glab CLI', () => {
      let capturedCmd = '';
      let capturedArgs: string[] = [];
      const adapter = createGitLabAdapter({
        execFn: (cmd, args) => {
          capturedCmd = cmd;
          capturedArgs = args;
          return '';
        },
      });
      adapter.editPrBase(42, 'main');
      expect(capturedCmd).toBe('glab');
      expect(capturedArgs).toEqual([
        'mr', 'update', '42',
        '--target-branch', 'main',
      ]);
    });

    it('throws when CLI fails', () => {
      const adapter = createGitLabAdapter({
        execFn: () => { throw new Error('glab not found'); },
      });
      expect(() => adapter.editPrBase(42, 'main')).toThrow('glab not found');
    });
  });
```

**Step 2: Add test cases for `markPrReady`**

```typescript
  describe('markPrReady', () => {
    it('passes correct args to glab CLI', () => {
      let capturedArgs: string[] = [];
      const adapter = createGitLabAdapter({
        execFn: (_cmd, args) => {
          capturedArgs = args;
          return '';
        },
      });
      adapter.markPrReady(42);
      expect(capturedArgs).toEqual(['mr', 'update', '42', '--ready']);
    });

    it('throws when CLI fails', () => {
      const adapter = createGitLabAdapter({
        execFn: () => { throw new Error('glab not found'); },
      });
      expect(() => adapter.markPrReady(42)).toThrow('glab not found');
    });
  });
```

**Step 3: Add test cases for `getBranchHead`**

```typescript
  describe('getBranchHead', () => {
    it('extracts SHA from glab api response', () => {
      const apiResponse = JSON.stringify({
        commit: { id: 'abc123def456' },
      });
      const adapter = createGitLabAdapter({
        execFn: () => apiResponse,
      });
      expect(adapter.getBranchHead('feature/auth')).toBe('abc123def456');
    });

    it('passes correct args to glab api', () => {
      let capturedArgs: string[] = [];
      const adapter = createGitLabAdapter({
        execFn: (_cmd, args) => {
          capturedArgs = args;
          return JSON.stringify({ commit: { id: 'abc123' } });
        },
      });
      adapter.getBranchHead('feature/auth');
      expect(capturedArgs).toEqual([
        'api', 'projects/:id/repository/branches/feature%2Fauth',
      ]);
    });

    it('returns empty string when CLI fails', () => {
      const adapter = createGitLabAdapter({
        execFn: () => { throw new Error('glab not found'); },
      });
      expect(adapter.getBranchHead('feature/auth')).toBe('');
    });
  });
```

**Step 4: Run tests to verify they fail**

```bash
cd tools/kanban-cli && npx vitest run tests/utils/code-host-gitlab.test.ts
```

Expected: FAIL — methods not yet implemented.

**Step 5: Commit failing tests**

```bash
git add tools/kanban-cli/tests/utils/code-host-gitlab.test.ts
git commit -m "test(5.5B): add failing tests for GitLab adapter new methods"
```

---

### Task 5: Implement GitLab adapter new methods

**Files:**
- Modify: `tools/kanban-cli/src/utils/code-host-gitlab.ts`

**Step 1: Add methods to the returned object**

In the `createGitLabAdapter` function, extend the returned object after the `getPRStatus` method:

```typescript
    editPrBase(prNumber: number, newBase: string): void {
      exec('glab', ['mr', 'update', String(prNumber), '--target-branch', newBase]);
    },

    markPrReady(prNumber: number): void {
      exec('glab', ['mr', 'update', String(prNumber), '--ready']);
    },

    getBranchHead(branch: string): string {
      try {
        const encoded = encodeURIComponent(branch);
        const json = exec('glab', [
          'api', `projects/:id/repository/branches/${encoded}`,
        ]);
        const data = JSON.parse(json) as { commit: { id: string } };
        return data.commit.id;
      } catch {
        return '';
      }
    },
```

**Note:** GitLab API requires URL-encoding for branch names with slashes (`feature/auth` → `feature%2Fauth`). `encodeURIComponent` handles this.

**Step 2: Run tests to verify they pass**

```bash
cd tools/kanban-cli && npx vitest run tests/utils/code-host-gitlab.test.ts
```

Expected: ALL PASS

**Step 3: Run full test suite to verify no regressions**

```bash
cd tools/kanban-cli && npm run verify
```

Expected: All 687+ tests pass, build/lint clean.

**Step 4: Commit**

```bash
git add tools/kanban-cli/src/utils/code-host-gitlab.ts
git commit -m "feat(5.5B): implement GitLab adapter editPrBase, markPrReady, getBranchHead"
```

---

### Task 6: Create `resolve-merge-conflicts` skill

**Files:**
- Create: `skills/resolve-merge-conflicts/SKILL.md`

**Step 1: Create the skill directory**

```bash
mkdir -p skills/resolve-merge-conflicts
```

**Step 2: Write the skill file**

Create `skills/resolve-merge-conflicts/SKILL.md` with this content:

```markdown
---
name: resolve-merge-conflicts
description: Use when git merge or git rebase results in conflicts - automates conflict resolution using codebase and stage context
---

# Resolve Merge Conflicts

## Purpose

Resolve git merge or rebase conflicts using full codebase context, parent/child stage documentation, and structured heuristics. Designed to be invoked from `phase-build` (during parent branch merging) and `rebase-child-mr` (Stage 6D, during child branch rebasing).

## Entry Conditions

- A `git merge` or `git rebase` operation has resulted in conflicts
- The working directory is in a merge/rebase conflict state
- Caller has context about which parent stage(s) are being merged/rebased

## Skill Flow

### Step 1: Identify Conflicting Files

```bash
git diff --name-only --diff-filter=U
```

Capture the list of all files with unresolved conflicts.

### Step 2: Auto-Resolve Trivially Conflicting Files

Handle these file types mechanically before any contextual analysis:

**Lock files** (`package-lock.json`, `yarn.lock`, `pnpm-lock.yaml`):
- Accept the current branch version: `git checkout --ours <file>`
- Regenerate: run `npm install` (or `yarn install` / `pnpm install` as appropriate)
- `git add <file>`

**Generated files** (`*.generated.ts`, `*.generated.graphql`, etc.):
- Accept the current branch version: `git checkout --ours <file>`
- Regenerate via project tooling (e.g., `npm run codegen`)
- `git add <file>`

**Config files with additive changes** (`.gitignore`, `.prettierrc`, `tsconfig.json`):
- Read the file with conflict markers
- Merge both sides: combine entries from both, deduplicate
- `git add <file>`

**Purely additive files** (changelogs, migration lists):
- Read the file with conflict markers
- Concatenate entries from both sides in chronological order
- `git add <file>`

Remove auto-resolved files from the conflicting files list before proceeding.

### Step 3: Context-Driven Resolution for Remaining Files

For each remaining conflicting file:

1. **Read the file** with conflict markers (shows `<<<<<<<`, `=======`, `>>>>>>>` blocks)

2. **Gather context**:
   - Read the parent stage's design doc (`STAGE-*-design.md`) and build notes (`STAGE-*-build.md`)
   - Read the current stage's design doc
   - Read relevant ticket descriptions if the conflict spans ticket boundaries
   - Examine surrounding code in the file for patterns and intent

3. **Apply resolution heuristics** (in priority order):

   | Priority | Pattern | Resolution |
   |----------|---------|------------|
   | 1 | **Complementary changes** — both sides add different things to different areas | Keep both, order logically |
   | 2 | **Superset** — one side includes the other's changes plus more | Keep the superset |
   | 3 | **Import/export conflicts** — both sides add imports or exports | Merge both lists, deduplicate |
   | 4 | **Type definition conflicts** — both sides add fields or methods | Merge both sets of fields/methods |
   | 5 | **Logic conflicts** — behavioral differences in code | Read stage design docs to determine intended direction; child stage intent takes precedence since parent is "done" (in PR) |
   | 6 | **Genuinely ambiguous** — two opposing patterns, no contextual signal | Escalate to user via AskUserQuestion |

4. **Resolve the conflict**: Replace conflict markers with the resolved content

5. **Mark as resolved**: `git add <file>`

### Step 4: Complete the Merge/Rebase

Determine which operation is in progress and complete it:

```bash
# Check if we're in a merge
if [ -f .git/MERGE_HEAD ] || [ -f ../.git/worktrees/*/MERGE_HEAD ]; then
  git merge --continue
# Otherwise we're in a rebase
else
  git rebase --continue
fi
```

### Step 5: Return Control to Caller

Return control to the calling skill (`phase-build` or `rebase-child-mr`). The caller is responsible for:
- Running verification (`npm run verify` or equivalent)
- Handling verification failures
- Deciding whether to escalate to the user

## What This Skill Does NOT Do

- **Does not run verification** — caller's responsibility
- **Does not modify stage frontmatter** or tracking files
- **Does not make architectural decisions** — resolves merge mechanics only
- **Does not push** — caller handles git push if needed

## Escalation Criteria

Only escalate to user via `AskUserQuestion` when ALL of these are true:
- The conflict involves logic/behavior (not just additive changes)
- Both sides implement contradictory behavior (not complementary)
- Neither stage design doc provides clear direction on intended behavior
- The codebase context doesn't suggest which direction is correct

Most conflicts are additive (new features on both sides) and can be resolved by keeping both changes.

## Stage 6D Reuse Note

The `rebase-child-mr` skill (Stage 6D) invokes this skill identically. The only difference is:
- `phase-build` triggers this after `git merge origin/<parent_branch>` fails
- `rebase-child-mr` triggers this after `git rebase <target>` fails

Step 4 handles both cases by checking whether `.git/MERGE_HEAD` exists.
```

**Step 3: Commit**

```bash
git add skills/resolve-merge-conflicts/SKILL.md
git commit -m "feat(5.5B): create resolve-merge-conflicts skill"
```

---

### Task 7: Update `phase-build` skill with parent branch merge step

**Files:**
- Modify: `skills/phase-build/SKILL.md`

**Step 1: Add Parent Branch Merge section**

Insert a new section **after** "## Worktree Awareness" and **before** "## Spec Handoff Protocol (CRITICAL)". The new section:

```markdown
## Parent Branch Merge

After worktree setup, check if the stage has parent dependencies whose MR branches need to be merged into the working branch.

**When to run:** Only if `pending_merge_parents` exists and is non-empty in the stage's YAML frontmatter.

**If `pending_merge_parents` is empty or not present:** Skip this section entirely.

### Merge Flow

1. Read `pending_merge_parents` from stage YAML frontmatter. Each entry has:
   - `stage_id`: Parent stage ID
   - `branch`: Parent's MR branch name
   - `pr_url`: Parent's PR/MR URL
   - `pr_number`: Parent's PR/MR number

2. For each parent in `pending_merge_parents`:
   ```bash
   git fetch origin
   git merge origin/<parent.branch> --no-edit
   ```
   - If merge succeeds: continue to next parent
   - If merge conflicts: invoke `resolve-merge-conflicts` skill, then continue

3. After ALL parents are merged, run full project verification:
   ```bash
   npm run verify  # or project equivalent
   ```

4. If verification fails:
   a. Analyze failures using full codebase context plus parent and child stage design docs
   b. Fix issues (type errors, test failures, lint issues from merge integration)
   c. Re-run verification
   d. Repeat until passing or until the direction is genuinely ambiguous
      (e.g., two patterns with opposite intentions, no clear path from context)
   e. Only escalate to user via AskUserQuestion if the correct direction cannot be determined from context

5. Proceed to planning phase with a clean, verified, merged baseline.

### Key Rules

- Fetch happens per parent (not once globally) — ensures fresh state for each parent branch
- `--no-edit` avoids interactive commit message editing
- `resolve-merge-conflicts` runs in the same session (not a subagent) — it needs full context
- Verification runs once after ALL parents are merged, not after each individual merge
- The session exhausts its own problem-solving ability before escalating to the user

### What This Step Does NOT Do

- Does not set `is_draft` or `mr_target_branch` — that's `phase-finalize`'s responsibility
- Does not modify `pending_merge_parents` — that's the sync engine's responsibility
- Does not push anything — Build phase works locally in the worktree
```

**Step 2: Update the Phase Workflow section**

In the Phase Workflow numbered list, add step 2.5 after the existing step 2 (Worktree Setup):

```
2.5. [CONDITIONAL: Parent Branch Merge]
   IF pending_merge_parents is non-empty in stage YAML frontmatter:
     → For each parent: git fetch origin && git merge origin/<parent.branch> --no-edit
     → If conflicts: invoke resolve-merge-conflicts skill
     → After all parents merged: run full npm run verify (or project equivalent)
     → If verify fails: analyze and fix using full context; only escalate if genuinely ambiguous
     → Result: clean, verified, merged baseline before planning begins
```

**Step 3: Update Phase Gates Checklist**

Add a new checkbox after "Worktree checked out":

```markdown
- [ ] Parent branches merged (if `pending_merge_parents` is non-empty) and verification passed
```

**Step 4: Commit**

```bash
git add skills/phase-build/SKILL.md
git commit -m "feat(5.5B): add parent branch merge step to phase-build skill"
```

---

### Task 8: Update `phase-finalize` skill with draft MR logic

**Files:**
- Modify: `skills/phase-finalize/SKILL.md`

**Step 1: Add Draft MR / Target Branch section**

Insert a new section **after** "## Remote Mode Detection" and **before** "## Phase Workflow". The new section:

```markdown
## Draft MR and Target Branch Logic

When creating MRs in remote mode, the target branch and draft status depend on the stage's `pending_merge_parents`.

### Determining Target Branch and Draft Status

Before creating the MR (step 13 in remote mode), determine:

1. Read `pending_merge_parents` from stage YAML frontmatter
2. Filter to only **unmerged** parents:
   - Read each parent's stage YAML to check if status is "Complete"
   - Or check parent's PR merge status via `gh pr view` / `glab mr view`
   - Remove any parent whose stage is Complete or whose PR is merged
3. Determine target branch:
   - **Zero unmerged parents** → default branch (`main` or `master`)
   - **Exactly one unmerged parent** → that parent's MR branch (`parent.branch`)
   - **Multiple unmerged parents** → default branch (`main` or `master`)
4. Determine draft status:
   - **Any unmerged parents** → create MR as **draft**
   - **Zero unmerged parents** → create MR as **ready** (normal)

### MR Description — Dependencies Section

If there are unmerged parents, append a Dependencies section to the MR body:

```markdown
## Dependencies

This MR depends on the following unmerged parent MRs:

- **STAGE-XXX-YYY-ZZZ**: [branch-name](PR_URL)

⚠️ This MR was created as a **draft** because parent dependencies are not yet merged.
```

Only list **unmerged** parents. Merged parents are omitted entirely.
If zero unmerged parents: no Dependencies section at all.

### Frontmatter Updates After MR Creation

After MR creation, update stage YAML frontmatter with:
- `is_draft: true` (if created as draft; omit or set false if ready)
- `mr_target_branch: <target_branch>` (the branch the MR targets)
- `pr_url` and `pr_number` (already handled by existing finalize logic)
```

**Step 2: Update Remote Mode step 13 (MR creation)**

Modify the existing step 13 in the Remote Mode workflow to incorporate draft/target logic. Replace the `gh pr create` and `glab mr create` commands:

**GitHub:**
```bash
# If draft (has unmerged parents):
gh pr create \
  --base <target_branch> \
  --draft \
  --title "feat(STAGE-XXX-YYY-ZZZ): <stage title>" \
  --body "$(cat <<'PRBODY'
## Summary
...existing template...

## Dependencies

This MR depends on the following unmerged parent MRs:

- **STAGE-XXX-YYY-ZZZ**: [branch-name](PR_URL)

⚠️ This MR was created as a **draft** because parent dependencies are not yet merged.

---
*Generated by Claude Code workflow — [STAGE-XXX-YYY-ZZZ]*
PRBODY
)"

# If ready (no unmerged parents):
gh pr create \
  --base <target_branch> \
  --title "feat(STAGE-XXX-YYY-ZZZ): <stage title>" \
  --body "...existing template without Dependencies section..."
```

**GitLab:**
```bash
# If draft (has unmerged parents):
glab mr create \
  --target-branch <target_branch> \
  --draft \
  --title "feat(STAGE-XXX-YYY-ZZZ): <stage title>" \
  --description "...template with Dependencies section..."

# If ready (no unmerged parents):
glab mr create \
  --target-branch <target_branch> \
  --title "feat(STAGE-XXX-YYY-ZZZ): <stage title>" \
  --description "...existing template without Dependencies section..."
```

**Step 3: Update Remote Mode step 17 (tracking updates)**

Add `is_draft` and `mr_target_branch` to the list of frontmatter fields updated:

```
- Update stage YAML frontmatter:
  - Set Finalize phase complete
  - Set status to "PR Created" (NOT "Complete")
  - Record MR/PR URL in stage file
  - Set `is_draft: true` if MR was created as draft
  - Set `mr_target_branch` to the target branch used
```

**Step 4: Update Remote Mode Phase Gates Checklist**

Add new checkboxes:

```markdown
- [ ] Target branch determined from `pending_merge_parents` (zero/one/multiple unmerged parents)
- [ ] MR created as draft if unmerged parents exist
- [ ] Dependencies section included in MR body for unmerged parents only
- [ ] `is_draft` and `mr_target_branch` set in stage YAML frontmatter
```

**Step 5: Commit**

```bash
git add skills/phase-finalize/SKILL.md
git commit -m "feat(5.5B): add draft MR and target branch logic to phase-finalize skill"
```

---

### Task 9: Run full verification

**Step 1: Run the full project verification**

```bash
cd tools/kanban-cli && npm run verify
```

Expected: All tests pass (existing 687 + new adapter tests), build clean, lint clean, type-check clean.

**Step 2: If any failures, fix them**

Address any type errors from the interface extension (other files importing `CodeHostAdapter` may need updates if they create mock implementations).

---

### Task 10: Final commit and documentation update

**Step 1: Update the handoff doc to mark 5.5B design and plan complete**

Read and update `docs/plans/stage-5.5b-skill-updates-handoff.md` to note that design and implementation plan are complete.

**Step 2: Commit**

```bash
git add docs/plans/stage-5.5b-skill-updates-handoff.md
git commit -m "docs: mark Stage 5.5B design and implementation plan complete"
```
